= EntityModule
:toc:

== General information

=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>across-standard-modules</groupId>
			<artifactId>entity-module</artifactId>
			<version>{across-version}</version>
		</dependency>
	</dependencies>
----

=== Module dependencies

.Module dependencies
|===
|Module |Type |Description

|<<integration:adminwebmodule>>
|optional
|Enables auto generated forms for managing the registered entities.
|===

=== Module settings

|===
|Property |Description |Default

|entityModule.entityValidator.registerForMvc
|Should the entity Validator instance be registered as the default validator for MVC databinding.
|true
|===

== About the EntityModule

=== Integration with Spring Data repositories

=== Creating an EntityConfiguration manually

=== Integration with other modules

[[integration:adminwebmodule]]
==== AdminWebModule

[[form-elements]]
== Form elements

Implementation is always disconnected from the selected value (entity).  Single form element could be used
to render multiple entities.

=== Form element types
Every `FormElement` has a unique element type `getElementType()`, this type is a simple String property that can be
 used how the element should render and behave.

.Common form element types
|===
|Element type |Description

|textbox
|

|hidden
|

|select
|

|multi-checkbox
|

|checkbox
|Renders a single checkbox.

|===

==== Type lookup strategy

.Default lookup strategy for common form element types
|===
|Property type |Form element type

| `String`, `Number`, `Date`
| textbox

| `Boolean`
| checkbox

| `Enum`
| select

| `Collection<?>`, `Array`
| multi-checkbox

|===

==== Specifying the default type for a property

=== Form element factories
hierarchy: assembler, builderfactory, builder, element (scopes)

messagecoderesolver

=== Common FormElement implementations
==== Basic functionality
label, value, required, print, customTemplate

==== HiddenFormElement
Renders a hidden HTML input type.

[source,html,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<!--/* hidden */-->
    <div th:if="${element.elementType eq 'hidden'}">
        <input type="hidden" th:name="${element.name}" th:value="${element.value(entity)}"/>
    </div>
----

==== CheckboxFormElement
Renders a single checkbox, the `isChecked(Object)` method can be used to determine if the checkbox should be checked
for the given entity.

[source,html,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<!--/* checkbox */-->
    <div th:if="${element.elementType eq 'checkbox'}" class="checkbox">
        <label th:for="${#ids.next(element.name)}">
            <input type="checkbox" th:id="${#ids.seq(element.name)}"
                   th:name="${element.name}"
                   th:checked="${element.isChecked(entity)}"/>
            <input type="hidden" th:name="|_${element.name}|" value="on"/>
            <span th:text="${element.label}">label</span>
        </label>
    </div>
----

==== TextboxFormElement
Renders either a text input type or a textarea depending on the `multiLine` property.
Supports `maxLength` property to specify the maximum length of text the box should support.

[source,html,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<!--/* textbox \*/-->
    <div th:if="${element.elementType eq 'textbox'}">
        <label th:for="${#ids.next(element.name)}">
            <span th:text="${element.label}">label text</span>
            <sup th:if="${element.required}"><strong>*</strong></sup>
        </label>
        <input th:unless="${element.multiLine}"
               th:id="${#ids.seq(element.name)}" type="text" th:name="${element.name}"
               class="form-control" th:value="${element.print(entity)}"
               th:attr="maxlength=${element.maxLength}"
                />
        <textarea th:if="${element.multiLine}" class="form-control"
                  th:id="${#ids.seq(element.name)}"
                  th:name="${element.name}"
                  th:text="${element.print(entity)}"
                  th:attr="maxlength=${element.maxLength}"/>
    </div>
----


==== SelectFormElement
This implementation is used for several element types and can be used to render any collection of selected values.
The `options` property determines the list of possible values in the form of `SelectOption` instances.  The associated
`SelectFormElementBuilder` takes a `SelectOptionGenerator` implementation that is used to generate the list of possible
options when building the element.

`SelectFormElement` provides a setter method for `elementType` because the base implementation can easily be used
for different types of controls.  The default template renders both `select` and `multi-checkbox` element types
from `SelectFormElement` instances.

[source,html,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<!--/* select \*/-->
    <div th:if="${element.elementType eq 'select' and not element.options.empty}">
        <label th:for="${#ids.next(element.name)}">
            <span th:text="${element.label}">label text</span>
            <sup th:if="${element.required}"><strong>*</strong></sup>
        </label>
        <select th:id="${#ids.seq(element.name)}" class="form-control" th:name="${element.name}"
                th:with="selectedValue = ${element.value(entity)}">
            <option th:if="${not element.required or selectedValue == null}"></option>
            <option th:each="option : ${element.options}"
                    th:value="${option.value}"
                    th:selected="${selectedValue != null and option.isSelected(selectedValue)}"
                    th:text="${option.label}"/>
        </select>
    </div>
    <!--/* multi checkbox \*/-->
    <div th:if="${element.elementType eq 'multi-checkbox' and not element.options.empty}">
        <label>
            <span th:text="${element.label}">label text</span>
            <sup th:if="${element.required}"><strong>*</strong></sup>
        </label>
        <div th:with="selectedValue = ${element.value(entity)}">
            <div th:each="option : ${element.options}" class="checkbox">
                <label th:for="${#ids.next(element.name)}">
                    <input type="checkbox"
                       th:id="${#ids.seq(element.name)}"
                       th:name="${element.name}"
                       th:value="${option.value}"
                       th:checked="${selectedValue != null and option.isSelected(selectedValue)}"/>
                    <span th:text="${option.label}">label text</span>
                </label>
                <input type="hidden" th:name="|_${element.name}|" value="on"/>
            </div>
        </div>
    </div>
----





