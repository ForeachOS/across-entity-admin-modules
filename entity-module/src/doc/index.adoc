= EntityModule
Arne Vandamme
2.1.0.RELEASE
:toc: left
:sectanchors:
:module-version: 2.1.0.RELEASE
:module-name: EntityModule
:module-artifact: entity-module
:module-url: https://foreach.atlassian.net/wiki/display/AX/EntityModule
:bitbucket-url: https://bitbucket.org/beforeach/entity-ui-module/src/5bcf5de44d5fb03632dfee13d9915db65bb5d268/entity-module/src/main
:bootstrap-ui-module-url: https://foreach.atlassian.net/wiki/display/AX/BootstrapUiModule
:admin-web-module-docs: http://across.foreach.be/docs/across-standard-modules/AdminWebModule/2.0.0.RELEASE/reference/
:javadoc: http://across.foreach.be/docs/across-standard-modules/EntityModule/2.1.0.RELEASE/javadoc
:javadoc-processors: {javadoc}/com/foreach/across/modules/entity/views/processors

[copyright,verbatim]
--
Copyright (C) 2014-2017 +
[small]#Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.#
--

[abstract]
== About
The EntityModule is responsible for automatically generating an administration UI of entities built.
It provides infrastructure to define an entity model and to generate default web pages based on that model.
By default all Spring Data repositories are introspected and corresponding entity models are built for every repository.

Module website: {module-url}

:numbered:
== General information

=== Artifact
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>com.foreach.across.modules</groupId>
			<artifactId>{module-artifact}</artifactId>
			<version>{module-version}</version>
		</dependency>
	</dependencies>
----

=== Module dependencies

.Module dependencies
|===
|Module |Type |Description

|<<integration:adminwebmodule>>
|optional
|Enables auto generated forms for managing the registered entities.
|===

=== Module settings

|===
|Property |Description |Default

|entityModule.entityValidator.registerForMvc
|Should the entity Validator instance be registered as the default validator for MVC databinding.
|true
|===

include::whats-new.adoc[]

:numbered:

include::chap-about.adoc[]

== Configuring entity types

[[builders]]
=== Using builders
Entities are usually automatically added to the `EntityRegistry` through the use of one or more `EntityRegistrar` beans.
The registrars will apply a default configuration, usually consisting of all properties, associations and views.

Customizing the `EntityRegistry` is done by implementing one or more `EntityConfigurer` beans in your modules.
These receive an `EntitiesConfigurationBuilder` that effectively allows you to customize all registered `EntityConfiguration` instances.
Multiple `EntityConfigurer` beans can modify the same `EntityConfiguration`, the order in which they are applied will determine the last value if they modify the same properties.

Investigate the javadoc of the `EntitiesConfigurationBuilder` and child builders to discover all possible configuration options.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@AcrossDepends(required = "EntityModule")
@Configuration
public class UserEntitiesConfiguration implements EntityConfigurer
{
	@Override
	public void configure( EntitiesConfigurationBuilder configuration ) {
		// By default permissions cannot be managed through the user interface
		configuration.withType( Permission.class ).hide();
	}
}
----

=== Configuring properties
Properties for an entity can be configured through the builders as well.
New properties can be added or the default properties can modified.
How properties are configured determines how they will be rendered on the generated forms.

hidden:: A hidden property will by default not be returned when requesting all properties from an `EntityPropertyRegistry`.
You can still get this property directly however, the `hidden` state means a property will not advertise itself, you must know of its existence.

readable:: Any readable property can be rendered in all views.
This state means that a form control can always be generated, even though it might very well be readonly if the property is not `writable`.

writable::  A writable property can be rendered in form views.
In case a property is writable but not readable, the property can only be included in forms but not in other views.

WARNING: The `hidden` state has no correlation with a hidden form control.
Setting a property to be rendered as a hidden form control can only be done through configuring the right `ViewElement` information for that property.

==== Configuring a label
An entity with a corresponding `EntityConfiguration` always has a label, this is a textual representation of the entity in for example lists.
This could be the *name* or the * title* property for example.
By default the label corresponds to a custom generated property *#label* that defaults to calling `toString()` on the entity.

You can configure the label using the `label()` method on a `PropertyDescriptorBuilder`.
This is equivalent to calling `property("#label")`.
If you want to use another property as the base for label generation, you can configure this on the `EntityConfigurationBuilder` by calling `label("propertyName")`.
This will copy all settings from the source property to the *#label* property, but keep in mind it still is a separate property that can be customized.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Override
public void configure( EntitiesConfigurationBuilder entities ) {
    // Configure the username to be used as label for a User entity
    entities.withType( User.class ).label( "username" );

    // Configure the group name to be used as base label, but modify the value fetcher so
    // the label is prefixed with Group
    entities.withType( Group.class )
            .properties( props -> props.label( "name" ).spelValueFetcher( "'Group: ' + name" ) );
}
----

If you do not wish to use the *#label* property at all as default entity label, you can customize the `Printer` used for label generation by modifying the `EntityModel`.

NOTE: As *#label* is a generated property, sorting is not enabled by default.
If you configure the label using an existing property, the sortable attribute will be copied as well and sorting on label will be possible.

=== Creating an EntityConfiguration manually

==== Attributes to configure

Some attributes are mandatory, others are optional but will often impact how much functionality is available out of the box.
You can configure any attribute you like, see the section on <<automatic-attributes,automatic registration>> for a list of common attributes provided by other registrars.

==== EntityQueryExecutor

In order for generated views to work automatically, an `EntityConfiguration` should have an `EntityQueryExecutor` attribute.
The `EntityQueryExecutor` is a generic interface that supports the simple `EntityQuery` abstraction for fetching entities from the backing repository.
Default implementations exist for `JpaSpecificationExecutor` and `QueryDslPredicateExecutor`.

==== Registering an ENUM as entity

EntityModule supports registration of enums as `EntityConfiguration`.
When creating an `EntityConfiguration` for an enum, a basic `EntityModule` will get built and all enum properties will be configurable.

Registering enums as entity is mainly useful for configuration of display properties in related entity views.

.Example registering an enum as entity
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
// Enum class
public enum Country
{
    BE( "Belgium" ),
    UK( "United Kingdom" ),
    NL( "Netherlands" );

    private String name;

    Country( String name ) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

// Create the EntityConfiguration
@Override
public void configure( EntitiesConfigurationBuilder entities ) {
    entities.create().entityType( Country.class, true ).label( "name" );
}
----

=== Automatic registration of entity types

==== Spring Data repositories

===== JPA repositories
DOCUMENTATION TODO:

 * Embedded ID
 * register conversion service
 * add json serializer

[[automatic-attributes]]
===== Automatic attribute registration
See the appendix for an <<appendix-entity-configuration-attributes,overview of commonly registered attributes>>.

== Integration with other modules

[[integration:adminwebmodule]]
==== AdminWebModule

If the AdminWebModule is present entity management controllers will be created for all registered entity configurations.
If you want to avoid the automatic registration of entity management controllers for a particular entity type, you should set the `EntityConfiguration` as `hidden`.
This will effectively disable the default entity controllers for that type, and hide the existence of the entity type from the administration interface.

You can also hide one or more associations.
By default an association will not be shown if one of the participating entities is hidden.
If you specify the `hidden` property of an `EntityAssociation` explicitly, that value will take precedence of the entity configurations.
This way it is possible to generate management pages for associated entities, but not for the main entity type.

==== AdminWebModule: developer tools
When integrated with AdminWebModule and development mode is active, an entity registry browser will be added to the _Developer tools_ section of the administration ui.
The browser allows you to inspect the registered entities along with their views, associations and properties.

include::chap-entity-associations.adoc[]

=== EntityLinkBuilder

An `EntityConfiguration` or `EntityAssociation` can have one or more `EntityLinkBuilder` instances registered in its attributes.
An `EntityLinkBuilder` is used to create application links to management controllers for the entity.
By default the `EntityModule` will create an `EntityLinkBuilder` for the management pages in admin web if `AdminWebModule` is present, and this link builder will be registered as the attribute with `EntityLinkBuilder` class as key.

You can use the `EntityLinkBuilder` directly for example in redirects, often the specific `EntityLinkBuilder` is overridable per view.
All links the `EntityLinkBuilder` generates are entirely configurable, please refer to the javadoc for all possible settings.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
EntityLinkBuilder linkBuilder = entityConfiguration.getAttribute( EntityLinkBuilder.class );

// Will create a link of the form "/entities/{parent}/{parentId}/update"
String path = linkBuilder.update( parent );
----

==== EntityLinkBuilder for associations
Associations usually also have an `EntityLinkBuilder` registered, it is possible to create links to items that are an association from a parent entity.
To achieve this you must _scope_ the `EntityLinkBuilder` to the parent entity it belongs to.

[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
EntityLinkBuilder linkBuilder = entityConfiguration.getAttribute( EntityLinkBuilder.class );

EntityConfiguration associated = association.getTargetEntityConfiguration();
EntityLinkBuilder associatedLinkBuilder = association.getAttribute( EntityLinkBuilder.class )
                                                     .asAssociationFor( linkBuilder, parent );

// Will create a link of the form "/entities/{parent}/{parentId}/associations/{associationName}/{childId}/update"
String path = associatedLinkBuilder.update( child );
----

include::chap-entity-views.adoc[]

include::chap-entity-views-customizing.adoc[]

== Default entity configuration

=== Auditable
If _SpringSecurityModule_ is present, {module-name} adapts the default views for `Auditable` entities.
The *createdBy* and *lastModifiedBy* properties are rendered using an `AuditablePrincipalPropertyViewElementBuilder` which uses the `SecurityPrincipalLabelResolverStrategy` to generate a pretty label for a principal (eg. full name instead of username).
The default properties are removed from default views, but an aggregated property *created* and *lastModified* is added.
The aggregated properties combine both the timestamp and the principal in a single property using the `AuditablePropertyViewElementBuilder`.

See the `AuditableEntityUiConfiguration` for full customization.

include::chap-entity-query.adoc[]

== Appendices
include::appendix-attributes.adoc[]
include::appendix-message-codes.adoc[]
include::appendix-view-processors.adoc[]

